---
phase: 01-spec-driven-architecture
plan: 01
type: execute
---

<objective>
Define the spec markdown format and create a parser module for the specs-as-source-truth pattern.

Purpose: Establish the foundation for the hybrid approach where markdown specs serve as the authoritative source of truth for requirements, while SQLite handles runtime status tracking.
Output: Spec format documentation, example templates, and a Python parser module.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

**Ralph Wiggum Reference Pattern:**
- Specs in `specs/` directory, one markdown file per topic of concern
- Topic passes "one sentence without 'and'" test
- No rigid template - let content dictate format
- Include acceptance criteria for verifiable outcomes
- Markdown over JSON for token efficiency

**Current Implementation:**
@api/database.py - Current Feature model with category, name, description, steps
@mcp_server/feature_mcp.py - Current MCP server reading from SQLite

**Design Decision:**
Hybrid approach - markdown specs for requirements, SQLite for runtime status tracking.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define spec markdown format</name>
  <files>docs/spec-format.md, .claude/templates/spec.template.md</files>
  <action>
Create the spec format documentation and template:

1. Create `docs/spec-format.md` defining the spec file structure:
   - Frontmatter with category, priority, status fields
   - Title as H1 (becomes feature name)
   - Description section (what and why)
   - Acceptance Criteria section (bulleted list of verifiable outcomes)
   - Test Steps section (numbered steps for verification)

2. Create `.claude/templates/spec.template.md` as the base template for new specs

Format design principles (from Ralph Wiggum):
- Keep it simple - markdown with minimal structure
- Frontmatter for machine-readable metadata only
- Human-readable prose for requirements
- Test steps map to current "steps" JSON array

Example structure:
```markdown
---
category: functional
priority: 1
status: pending
---

# User Login with Email

Users can authenticate using their email and password.

## Acceptance Criteria

- Login form accepts email and password
- Invalid credentials show error message
- Successful login redirects to dashboard
- Session persists after page refresh

## Test Steps

1. Navigate to /login
2. Enter test@example.com in email field
3. Enter "password123" in password field
4. Click Login button
5. Verify redirect to /dashboard
6. Refresh page and verify still logged in
```

Do NOT create a complex schema - keep it minimal and human-readable.
  </action>
  <verify>
cat docs/spec-format.md | head -50
cat .claude/templates/spec.template.md
  </verify>
  <done>
- docs/spec-format.md exists with format documentation
- .claude/templates/spec.template.md exists as usable template
- Format includes frontmatter, description, acceptance criteria, test steps
  </done>
</task>

<task type="auto">
  <name>Task 2: Create spec parser module</name>
  <files>spec_parser.py</files>
  <action>
Create a Python module to parse spec markdown files into structured data:

1. Create `spec_parser.py` in the root directory with:
   - `parse_spec(filepath: Path) -> dict` - Parse single spec file
   - `parse_specs_directory(specs_dir: Path) -> list[dict]` - Parse all specs
   - `spec_to_feature_dict(spec: dict) -> dict` - Convert to Feature-compatible format

2. Use standard library only (no new dependencies):
   - `re` for markdown parsing
   - `pathlib` for file handling
   - Parse YAML frontmatter manually (between `---` markers)

3. Return structure compatible with current Feature model:
   ```python
   {
       "category": str,      # from frontmatter
       "priority": int,      # from frontmatter (default 999)
       "name": str,          # from H1 title
       "description": str,   # from description section
       "steps": list[str],   # from Test Steps section
       "status": str,        # from frontmatter (pending/passing)
       "filepath": str       # source file path
   }
   ```

4. Handle edge cases:
   - Missing frontmatter defaults to category="functional", priority=999
   - Missing sections return empty strings/lists
   - Non-.md files are skipped

Do NOT use external YAML parser - implement simple frontmatter parsing inline.
This keeps dependencies minimal and the module portable.
  </action>
  <verify>
python -c "from spec_parser import parse_spec, parse_specs_directory; print('Import OK')"
python -c "
from pathlib import Path
from spec_parser import parse_spec

# Create test spec
test_content = '''---
category: functional
priority: 1
---

# Test Feature

A test feature description.

## Acceptance Criteria

- Criterion 1
- Criterion 2

## Test Steps

1. Step one
2. Step two
'''
Path('test_spec.md').write_text(test_content)
result = parse_spec(Path('test_spec.md'))
assert result['name'] == 'Test Feature', f'Got: {result}'
assert result['category'] == 'functional'
assert len(result['steps']) == 2
print('Parser test passed')
Path('test_spec.md').unlink()
"
  </verify>
  <done>
- spec_parser.py exists with parse_spec, parse_specs_directory, spec_to_feature_dict functions
- Parser correctly extracts frontmatter, title, description, acceptance criteria, steps
- Parser handles missing/malformed files gracefully
- No new dependencies added
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] docs/spec-format.md documents the spec format clearly
- [ ] .claude/templates/spec.template.md is a valid, usable template
- [ ] spec_parser.py imports without errors
- [ ] Parser correctly parses example spec file
- [ ] No new dependencies in requirements.txt
- [ ] `ruff check spec_parser.py` passes (or fix any issues)
</verification>

<success_criteria>
- Spec format defined and documented
- Parser module functional and tested
- Foundation ready for initializer to generate specs
</success_criteria>

<output>
After completion, create `.planning/phases/01-spec-driven-architecture/01-01-SUMMARY.md` following the summary template.
</output>
