---
phase: 01-spec-driven-architecture
plan: 03
type: execute
---

<objective>
Integrate the spec parser with the MCP server and update prompts to reference specs as source of truth.

Purpose: Complete the hybrid architecture by having the MCP server read feature content from specs/ and status from SQLite, while prompts guide agents to work from specs.
Output: Updated MCP server, coding prompt, and seamless spec-database integration.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Depends on 01-01 and 01-02:**
@spec_parser.py - Spec parser module
@docs/spec-format.md - Spec format documentation
@.claude/templates/initializer_prompt.template.md - Updated initializer
@.claude/templates/agents.template.md - AGENTS.md template

**Current Implementation:**
@mcp_server/feature_mcp.py - Current MCP server (SQLite only)
@.claude/templates/coding_prompt.template.md - Current coding prompt
@api/database.py - Feature database model
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update MCP server for spec-first pattern</name>
  <files>mcp_server/feature_mcp.py</files>
  <action>
Modify the MCP server to use a hybrid approach:

1. On startup (in server_lifespan):
   - Check if specs/ directory exists
   - If specs exist but database is empty: load specs into database using spec_parser
   - If both exist: specs are authoritative for content, database for status

2. Update feature_get_next to:
   - Return spec content (description, steps) from parsed spec file
   - Return status (passes, in_progress, priority) from database
   - Include spec filepath in response for reference

3. Add new tool `feature_sync_from_specs`:
   - Re-parse specs/ directory
   - Update database with any new/changed specs
   - Preserve status (passes, in_progress) for existing features
   - Match specs to features by name (H1 title)

4. Keep existing tools working:
   - feature_mark_passing: updates database only (status)
   - feature_skip: updates database only (priority)
   - feature_get_stats: queries database
   - feature_create_bulk: keep for backwards compatibility

Import spec_parser at top:
```python
from spec_parser import parse_specs_directory, spec_to_feature_dict
```

The key insight: specs/ is authoritative for WHAT to build, database tracks PROGRESS.

Do NOT remove any existing tools - maintain backwards compatibility.
Projects without specs/ should work exactly as before.
  </action>
  <verify>
# Check syntax
python -m py_compile mcp_server/feature_mcp.py && echo "Syntax OK"

# Check imports work
python -c "
import sys
sys.path.insert(0, '.')
from mcp_server.feature_mcp import mcp
print('Import OK')
"

# Check new tool exists
grep -q "feature_sync_from_specs" mcp_server/feature_mcp.py && echo "Sync tool added"
  </verify>
  <done>
- MCP server loads specs on startup if specs/ exists
- feature_get_next returns spec content with database status
- feature_sync_from_specs tool added for re-syncing
- Backwards compatible - projects without specs/ work as before
  </done>
</task>

<task type="auto">
  <name>Task 2: Update coding prompt for specs pattern</name>
  <files>.claude/templates/coding_prompt.template.md</files>
  <action>
Update the coding prompt to reference specs as source of truth:

1. Update "GET YOUR BEARINGS" section:
   - Add: `ls specs/` to see available specs
   - Add: `cat AGENTS.md` for operational reference
   - Keep existing git log and feature_get_stats checks

2. Add "UNDERSTANDING SPECS" section after bearings:
   - Explain specs/ directory structure
   - Note: specs are authoritative for requirements
   - Note: database tracks completion status

3. Update "CHOOSE ONE FEATURE" section:
   - When feature_get_next returns, also read the spec file
   - The spec file has full acceptance criteria
   - Steps in database may be summary; spec has details

4. Add note about AGENTS.md:
   - Read AGENTS.md for quick build/run commands
   - Don't need to parse app_spec.txt for basic operations

5. Keep all existing TDD and verification guidance - it's excellent

Do NOT remove or significantly change the TDD mindset section.
Do NOT remove the verification test requirements.
These are critical for quality.
  </action>
  <verify>
# Check specs/ mentioned
grep -q "specs/" .claude/templates/coding_prompt.template.md && echo "specs/ referenced"
# Check AGENTS.md mentioned
grep -q "AGENTS.md" .claude/templates/coding_prompt.template.md && echo "AGENTS.md referenced"
# Check TDD section preserved
grep -q "TEST-DRIVEN DEVELOPMENT" .claude/templates/coding_prompt.template.md && echo "TDD preserved"
  </verify>
  <done>
- Coding prompt references specs/ as source of truth
- AGENTS.md referenced for operational commands
- TDD mindset and verification requirements preserved
- Clear guidance on spec vs database relationship
  </done>
</task>

<task type="auto">
  <name>Task 3: Create migration guide for existing projects</name>
  <files>docs/migration-to-specs.md</files>
  <action>
Create a migration guide for converting existing projects to specs pattern:

1. Create `docs/migration-to-specs.md` with:
   - Overview of the change (database â†’ hybrid)
   - Step-by-step migration process
   - How to generate specs from existing features.db
   - Verification steps

2. Include migration script example:
   ```bash
   # Export existing features to specs/
   python -c "
   from api.database import create_database, Feature
   from pathlib import Path
   import re

   project_dir = Path('.')
   engine, Session = create_database(project_dir)
   session = Session()

   specs_dir = project_dir / 'specs'
   specs_dir.mkdir(exist_ok=True)

   for feature in session.query(Feature).order_by(Feature.priority):
       # Sanitize name for filename
       safe_name = re.sub(r'[^a-z0-9]+', '-', feature.name.lower()).strip('-')
       filename = f'{feature.priority:03d}-{safe_name}.md'

       content = f'''---
   category: {feature.category}
   priority: {feature.priority}
   status: {'passing' if feature.passes else 'pending'}
   ---

   # {feature.name}

   {feature.description}

   ## Test Steps

   '''
       for i, step in enumerate(feature.steps, 1):
           content += f'{i}. {step}\n'

       (specs_dir / filename).write_text(content)
       print(f'Created {filename}')
   "
   ```

3. Note that migration is optional - existing projects work without specs

Do NOT make migration mandatory. The MCP server handles both patterns.
  </action>
  <verify>
cat docs/migration-to-specs.md | head -30
  </verify>
  <done>
- Migration guide created with step-by-step instructions
- Script example for exporting features to specs
- Clear note that migration is optional
- Phase 1 complete
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] MCP server imports spec_parser without errors
- [ ] MCP server has feature_sync_from_specs tool
- [ ] Coding prompt references specs/ and AGENTS.md
- [ ] Migration guide exists with working script example
- [ ] `ruff check mcp_server/feature_mcp.py` passes
- [ ] All existing MCP tools still work
</verification>

<success_criteria>
- Hybrid spec-database architecture complete
- MCP server reads specs for content, database for status
- Coding agent guided to work from specs
- Migration path documented for existing projects
- Phase 1: Spec-Driven Architecture complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-spec-driven-architecture/01-03-SUMMARY.md` following the summary template.

This is the final plan for Phase 1. After completing this plan:
1. Update .planning/STATE.md to mark Phase 1 complete
2. Update .planning/ROADMAP.md progress table
3. Ready for Phase 2: Deterministic Loop
</output>
