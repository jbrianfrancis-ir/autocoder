# Phase 5 Plan 2: Sandbox Hardening - Process Isolation

**Phase**: 05-sandbox-hardening
**Plan**: 02 of 02
**Scope**: Medium (~45 min)
**Prerequisites**: Plan 05-01 complete

<objective>
Add process-level isolation controls: resource limits for subprocesses, environment sanitization, and command allowlist audit for dangerous subcommand patterns.

**Key outcomes:**
- Resource limits (CPU, memory, file size) applied to subprocess execution
- Subprocess environment sanitized to prevent credential leakage
- Allowlist audit documents dangerous patterns in git/npm with recommendations
</objective>

<execution_context>
**Load first:**
@.planning/phases/05-sandbox-hardening/05-RESEARCH.md (code examples for setrlimit)
@security.py (current allowlist implementation)

**Reference:**
@.planning/codebase/BLAST_RADIUS.md (from 05-01, update if needed)
</execution_context>

<context>
**From Phase Research (05-RESEARCH.md):**
- Resource limits via `setrlimit` prevent DoS attacks
- Subprocess inherits full parent environment by default (credential leak risk)
- Git/npm commands can execute arbitrary code via subcommands

**Current state:**
- `security.py` has 57 allowed commands
- `security.py` validates pkill/chmod/init.sh with extra checks
- No resource limits on subprocess execution
- Agent subprocess likely inherits full environment

**From 05-01:**
- CORS and symlink issues addressed
- BLAST_RADIUS.md exists documenting security posture
</context>

<tasks>
## Task 1: Add Resource Limits Helper

**Objective:** Create helper function to apply CPU/memory/file size limits

**Files:**
- `security.py` - Add `get_resource_limits()` and `apply_resource_limits()` functions

**Steps:**
1. Read `security.py` for existing structure
2. Add resource limit constants:
   ```python
   # Resource limits for subprocess execution
   RESOURCE_LIMITS = {
       "cpu_seconds": 300,      # 5 minutes CPU time
       "memory_bytes": 1024 * 1024 * 1024,  # 1GB memory
       "file_size_bytes": 100 * 1024 * 1024,  # 100MB max file size
       "max_processes": 50,     # Limit child processes
   }
   ```
3. Add `apply_resource_limits()` function for use as `preexec_fn`:
   ```python
   def apply_resource_limits():
       """Pre-exec function to apply resource limits to subprocess."""
       import resource
       limits = RESOURCE_LIMITS
       resource.setrlimit(resource.RLIMIT_CPU,
           (limits["cpu_seconds"], limits["cpu_seconds"]))
       resource.setrlimit(resource.RLIMIT_AS,
           (limits["memory_bytes"], limits["memory_bytes"]))
       resource.setrlimit(resource.RLIMIT_FSIZE,
           (limits["file_size_bytes"], limits["file_size_bytes"]))
       resource.setrlimit(resource.RLIMIT_NPROC,
           (limits["max_processes"], limits["max_processes"]))
   ```
4. Add platform guard (resource module is Unix-only)

**Verification:**
- [ ] `mypy security.py` passes
- [ ] Function imports successfully on Linux/macOS

**Commit:** `feat(05-02): add resource limits helper for subprocess execution`

---

## Task 2: Add Environment Sanitization Helper

**Objective:** Create helper to sanitize environment before subprocess execution

**Files:**
- `security.py` - Add `get_safe_environment()` function

**Steps:**
1. Add `get_safe_environment()` function:
   ```python
   def get_safe_environment(project_dir: str | None = None) -> dict[str, str]:
       """Create sanitized environment for subprocess execution.

       Removes sensitive variables and provides minimal safe environment.
       """
       import os

       # Start with minimal safe environment
       safe_env = {
           "PATH": os.environ.get("PATH", "/usr/bin:/bin"),
           "LANG": os.environ.get("LANG", "C.UTF-8"),
           "HOME": project_dir or os.environ.get("HOME", ""),
           "TERM": os.environ.get("TERM", "xterm-256color"),
       }

       # Allow specific development variables
       ALLOWED_ENV_VARS = {
           "NODE_ENV", "PYTHON_PATH", "PYTHONPATH",
           "npm_config_cache", "XDG_CACHE_HOME",
       }

       for var in ALLOWED_ENV_VARS:
           if var in os.environ:
               safe_env[var] = os.environ[var]

       return safe_env
   ```
2. Document which variables are allowed and why

**Verification:**
- [ ] `mypy security.py` passes
- [ ] Function returns dict without sensitive vars (test manually)

**Commit:** `feat(05-02): add environment sanitization helper`

---

## Task 3: Audit Command Allowlist for Dangerous Patterns

**Objective:** Document dangerous subcommand patterns in allowed commands

**Files:**
- `.planning/codebase/COMMAND_AUDIT.md` - New audit document

**Steps:**
1. Analyze allowed commands for code execution capabilities:
   - `git` - Can execute via `git config alias`, hooks
   - `npm` - Can execute via lifecycle scripts
   - `node` - Direct code execution
   - `bash`/`sh` - Direct shell execution
   - `docker` - Container commands could be abused
2. Document each with:
   - Command name
   - Dangerous patterns
   - Current mitigation (if any)
   - Recommended additional validation (future)
3. Add recommendations section for future hardening

**Example entry:**
```markdown
### git
**Risk:** Can execute arbitrary code via aliases, hooks, or `git config --global`
**Dangerous patterns:**
- `git config --global alias.x '!malicious'`
- `git clone` with hooks in remote repo
- `git submodule` can clone arbitrary repos
**Current mitigation:** None
**Recommendation:** Consider validating git subcommands, block `config --global`
```

**Verification:**
- [ ] All 57 commands reviewed
- [ ] High-risk commands documented with patterns

**Commit:** `docs(05-02): audit command allowlist for dangerous patterns`

---

## Task 4: Update BLAST_RADIUS.md with New Controls

**Objective:** Update blast radius documentation with new security controls

**Files:**
- `.planning/codebase/BLAST_RADIUS.md` - Update with new mitigations

**Steps:**
1. Add section on resource limits
2. Add section on environment sanitization
3. Reference COMMAND_AUDIT.md for detailed command analysis
4. Update "known gaps" section with audit findings

**Verification:**
- [ ] BLAST_RADIUS.md reflects new controls
- [ ] References to new helpers are accurate

**Commit:** `docs(05-02): update blast radius with process isolation controls`
</tasks>

<verification>
After all tasks:
1. `mypy security.py` - No type errors
2. `python -c "from security import apply_resource_limits, get_safe_environment; print('OK')"` - Imports work
3. COMMAND_AUDIT.md exists with all commands reviewed
4. BLAST_RADIUS.md updated with new controls
</verification>

<success_criteria>
- [ ] Resource limits helper function added to security.py
- [ ] Environment sanitization helper added to security.py
- [ ] Command allowlist audit completed with documented risks
- [ ] BLAST_RADIUS.md updated with new security controls
- [ ] All verification checks pass
</success_criteria>

<output>
**Files modified:**
- `security.py` - Resource limits and environment sanitization helpers
- `.planning/codebase/BLAST_RADIUS.md` - Updated security documentation

**Files created:**
- `.planning/codebase/COMMAND_AUDIT.md` - Command allowlist security audit

**Decisions to document:**
- Resource limit values chosen (5 min CPU, 1GB RAM, 100MB files, 50 processes)
- Environment variables allowed through sanitization
- Commands identified as high-risk for future validation

**Note:** These helpers are added but not yet wired into the agent subprocess execution.
Wiring them in would require changes to `client.py` or `autonomous_agent_demo.py`,
which is deferred to avoid scope creep. The helpers are ready for use.
</output>

---
*Plan created: 2026-01-11*
*Phase: 05-sandbox-hardening*
*Depends on: Plan 05-01*
